<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8-bit Music Sequencer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            background: linear-gradient(180deg, #090040 0%, #471396 100%);
            color: #FFCC00;
            font-family: 'Press Start 2P', cursive;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            overflow-x: hidden;
            user-select: none;
            cursor: default;
        }

        /* Container */
        .container {
            background: rgba(9, 0, 64, 0.8);
            border: 4px solid #FFCC00;
            box-shadow: 0 0 20px rgba(177, 59, 255, 0.5);
            padding: 1.5rem;
            border-radius: 15px;
        }

        /* Header */
        h1 {
            font-size: clamp(2rem, 5vw, 2.5rem);
            color: #FFCC00;
            text-shadow: 0 0 10px #B13BFF, 0 0 20px #B13BFF;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            animation: neon-flicker 2s infinite;
        }

        /* Grid cells */
        .grid-cell {
            width: 18px;
            height: 18px;
            background-color: #1C0B5B; /* Darker purple for empty cells */
            border: 1px solid #471396;
            cursor: pointer;
            transition: background-color 0.1s ease-in-out;
            position: relative;
            box-sizing: border-box;
        }
        .grid-cell.active {
            border: 1px solid #090040;
        }
        .grid-cell.active.duration-16n {
            background-color: #9ae6b4; /* Lightest green */
            min-width: 18px;
        }
        .grid-cell.active.duration-8n {
            background-color: #68d391; /* Lighter green */
            min-width: 36px;
        }
        .grid-cell.active.duration-4n {
            background-color: #48bb78; /* Standard green */
            min-width: 72px;
        }
        .grid-cell.active.duration-2n {
            background-color: #38a169; /* Slightly darker green */
            min-width: 144px;
        }
        .grid-cell.active.duration-1n {
            background-color: #2f855a; /* Darkest green */
            min-width: 288px;
        }
        .grid-cell.playing {
            background-color: #FFCC00; /* Yellow for playback */
            border: 2px solid #090040;
            box-shadow: 0 0 10px rgba(177, 59, 255, 0.8);
            z-index: 1;
        }

        /* Buttons */
        .instrument-button, .duration-button, .control-button, .style-button {
            font-size: clamp(0.875rem, 2vw, 1rem);
            padding: 0.75rem 1.5rem;
            background: linear-gradient(45deg, #471396, #B13BFF);
            color: #FFCC00;
            border: 3px solid #FFCC00;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Press Start 2P', cursive;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            box-shadow: 0 0 10px rgba(177, 59, 255, 0.5);
            animation: neon-flicker 2s infinite;
        }
        .instrument-button:hover, .duration-button:hover, .control-button:hover, .style-button:hover {
            background: linear-gradient(45deg, #B13BFF, #471396);
            transform: translateY(-3px);
            box-shadow: 0 0 20px rgba(177, 59, 255, 0.8);
            color: #090040;
        }
        .instrument-button.selected, .duration-button.selected {
            background: #B13BFF;
            border-color: #FFCC00;
            box-shadow: 0 0 20px rgba(177, 59, 255, 0.8);
            transform: translateY(-3px);
        }
        .control-button:disabled {
            background: #471396;
            border-color: #666;
            color: #999;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Tempo input */
        .tempo-input {
            background: rgba(9, 0, 64, 0.8);
            border: 2px solid #FFCC00;
            color: #FFCC00;
            box-shadow: 0 0 10px rgba(177, 59, 255, 0.5);
            border-radius: 10px;
            padding: 0.5rem;
            font-family: 'Press Start 2P', cursive;
            text-align: center;
        }

        /* Grid container */
        .grid-container {
            display: flex;
            width: 100%;
            max-width: 100%;
            position: relative;
            background: rgba(9, 0, 64, 0.8); /* Match container bg for padding area */
            border-radius: 10px; /* Rounded edges */
            overflow: hidden; /* Clip shadows */
        }

        /* Note labels */
        .note-labels {
            width: 110px;
            flex-shrink: 0;
            background: rgba(9, 0, 64, 0.8);
            border-right: 1px solid #471396;
            z-index: 10; /* Above grid shadows */
        }
        .note-label {
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-right: 8px;
            padding-left: 4px;
            background: rgba(9, 0, 64, 0.8);
            border-bottom: 1px solid #471396;
            position: sticky;
            left: 0;
            z-index: 10;
            color: #FFCC00;
            font-size: 0.75rem;
            text-shadow: 0 0 5px #B13BFF;
        }
        .volume-button {
            width: 18px;
            height: 18px;
            background: linear-gradient(45deg, #471396, #B13BFF);
            color: #FFCC00;
            border: 1px solid #FFCC00;
            font-size: 0.6rem;
            line-height: 18px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 5px rgba(177, 59, 255, 0.5);
        }
        .volume-button:hover {
            background: linear-gradient(45deg, #B13BFF, #471396);
            box-shadow: 0 0 10px rgba(177, 59, 255, 0.8);
        }
        .volume-display {
            width: 30px;
            text-align: center;
            font-size: 0.65rem;
            color: #FFCC00;
            text-shadow: 0 0 5px #B13BFF;
        }

        /* Tempo bar */
        .tempo-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 18px;
            height: calc(100% - 40px); /* Adjust for padding-bottom */
            background: #B13BFF;
            box-shadow: 0 0 20px rgba(177, 59, 255, 0.8);
            z-index: 3;
            transition: left 0.3s linear;
            pointer-events: none;
            animation: neon-flicker 1s infinite;
        }
        .grid-cell, .instrument-button, .duration-button, .control-button, .style-button, .volume-button {
            touch-action: none;
        }
        /* Grid wrapper */
        .grid-wrapper {
            flex-grow: 1;
            overflow-x: auto;
            max-width: calc(100% - 110px);
            touch-action: pan-x;
            position: relative;
            padding-bottom: 40px; /* Extra touch area for scrolling */
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: #B13BFF rgba(9, 0, 64, 0.8); /* Firefox */
        }
        /* WebKit scrollbar */
        .grid-wrapper::-webkit-scrollbar {
            height: 12px; /* Prominent scrollbar */
        }
        .grid-wrapper::-webkit-scrollbar-track {
            background: rgba(9, 0, 64, 0.8);
            border-radius: 6px;
        }
        .grid-wrapper::-webkit-scrollbar-thumb {
            background: linear-gradient(90deg, #471396, #B13BFF);
            border-radius: 6px;
            border: 2px solid #FFCC00;
            box-shadow: 0 0 10px rgba(177, 59, 255, 0.5);
        }
        .grid-wrapper::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(90deg, #B13BFF, #471396);
        }

        /* Scroll shadows */
        .grid-wrapper::before,
        .grid-wrapper::after {
            content: '';
            position: absolute;
            top: 0;
            height: 100%;
            width: 30px;
            z-index: 2; /* Above grid, below tempo-bar */
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .grid-wrapper::before {
            left: 0;
            background: linear-gradient(to right, rgba(177, 59, 255, 0.5), transparent);
            opacity: 0; /* Hidden by default */
        }
        .grid-wrapper::after {
            right: 0;
            background: linear-gradient(to left, rgba(177, 59, 255, 0.5), transparent);
            opacity: 0; /* Hidden by default */
        }
        .grid-wrapper.scroll-left::before {
            opacity: 1; /* Show when scrolled right */
        }
        .grid-wrapper.scroll-right::after {
            opacity: 1; /* Show when not fully scrolled */
        }

        /* Grid */
        .grid {
            display: grid;
            border: 1px solid #B13BFF;
            background: #090040;
            position: relative;
            z-index: 1; /* Below shadows */
        }
        .grid::before {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            background: rgba(177, 255, 255, 0.3);
            z-index: 2;
            left: 0;
        }

        /* Message box */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            background: rgba(9, 0, 64, 0.8);
            border: 2px solid #FFCC00;
            padding: 1rem;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(177, 59, 255, 0.5);
            opacity: 1;
            transition: opacity 0.3s ease-in-out;
        }
        .message-box.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .message-box p {
            color: #FFCC00;
            text-shadow: 0 0 5px #B13BFF;
        }

        /* Highlight and animation effects */
        .grid.duration-highlight {
            box-shadow: 0 0 15px rgba(177, 59, 255, 0.7);
        }
        .grid.randomized {
            animation: flash 0.5s;
        }
        @keyframes flash {
            0% { background-color: #471396; }
            100% { background-color: #090040; }
        }
        @keyframes neon-flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .grid-cell {
                width: 14px;
                height: 14px;
            }
            .grid-cell.active.duration-16n {
                min-width: 14px;
            }
            .grid-cell.active.duration-8n {
                min-width: 28px;
            }
            .grid-cell.active.duration-4n {
                min-width: 56px;
            }
            .grid-cell.active.duration-2n {
                min-width: 112px;
            }
            .grid-cell.active.duration-1n {
                min-width: 224px;
            }
            .note-labels {
                width: 70px;
            }
            .note-label {
                height: 14px;
                font-size: 0.65rem;
            }
            .volume-button {
                width: 14px;
                height: 14px;
                font-size: 0.5rem;
            }
            .volume-display {
                width: 20px;
                font-size: 0.55rem;
            }
            .grid-wrapper {
                max-width: calc(100% - 70px);
                padding-bottom: 30px; /* Smaller padding on mobile */
            }
            .instrument-button, .duration-button, .control-button, .style-button {
                padding: 0.5rem 0.75rem;
                font-size: clamp(0.75rem, 2vw, 0.875rem);
            }
            .tempo-bar {
                width: 14px;
            }
            .grid-wrapper::-webkit-scrollbar {
                height: 10px; /* Slightly smaller on mobile */
            }
            .container {
                padding: 1rem;
            }
            .message-box {
                width: 80%;
                text-align: center;
            }
        }
</style>
</head>
<body class="antialiased">
    <div class="container p-6 rounded-lg flex flex-col items-center">
        <h1 class="text-3xl mb-6 text-center text-yellow-300">Blurry Tune Maker</h1>

        <!-- Instrument Selection -->
         <label class="text-lg">Choose A Sound:</label>
        <div class="mb-4 flex flex-wrap justify-center gap-3">
            <button id="squareBtn" class="instrument-button py-2 px-4 rounded-md" role="button" aria-label="Select Square Wave">Square</button>
            <button id="triangleBtn" class="instrument-button py-2 px-4 rounded-md selected" role="button" aria-label="Select Triangle Wave">Triangle</button>
            <button id="sawtoothBtn" class="instrument-button py-2 px-4 rounded-md" role="button" aria-label="Select Sawtooth Wave">Sawtooth</button>
            <button id="noiseBtn" class="instrument-button py-2 px-4 rounded-md" role="button" aria-label="Select Noise (Drums)">Noise (Drums)</button>
        </div>

        <!-- Note Duration Selection -->
         <label class="text-lg">Choose Note Length:</label>
        <div class="mb-6 flex flex-wrap justify-center gap-3">
            <button id="duration16nBtn" class="duration-button py-2 px-4 rounded-md" role="button" aria-label="Select Sixteenth Note">Sixteenth Note</button>
            <button id="duration8nBtn" class="duration-button py-2 px-4 rounded-md" role="button" aria-label="Select Eighth Note">Eighth Note</button>
            <button id="duration4nBtn" class="duration-button py-2 px-4 rounded-md selected" role="button" aria-label="Select Quarter Note">Quarter Note</button>
            <button id="duration2nBtn" class="duration-button py-2 px-4 rounded-md" role="button" aria-label="Select Half Note">Half Note</button>
            <button id="duration1nBtn" class="duration-button py-2 px-4 rounded-md" role="button" aria-label="Select Whole Note">Whole Note</button>
        </div>

        <!-- Sequencer Grid with Labels -->
        <div class="grid-container flex">
            <div class="note-labels">
                <!-- Labels will be dynamically generated here -->
            </div>
            <div class="grid-wrapper">
                <div id="sequencerGrid" class="grid border border-gray-700"></div>
                <div id="tempoBar" class="tempo-bar"></div>
            </div>
        </div>

        <!-- Controls -->
        <div class="mt-6 flex flex-wrap justify-center items-center gap-4">
            <button id="playBtn" class="control-button py-2 px-6 rounded-md" role="button" aria-label="Play Sequence">Play</button>
            <button id="stopBtn" class="control-button py-2 px-6 rounded-md" role="button" aria-label="Stop Sequence">Stop</button>
            <button id="clearBtn" class="control-button py-2 px-6 rounded-md" role="button" aria-label="Clear Grid">Clear</button>
            <button id="saveBtn" class="control-button py-2 px-6 rounded-md" role="button" aria-label="Save Sequence">Save</button>
            <button id="loadBtn" class="control-button py-2 px-6 rounded-md" role="button" aria-label="Load Sequence">Load</button>
            <button id="randomizeBtn" class="control-button py-2 px-6 rounded-md" role="button" aria-label="Randomize Grid">Randomize</button>
            <button id="exportBtn" class="control-button py-2 px-6 rounded-md" role="button" aria-label="Export as WAV">Export WAV</button>
        </div>
        <div class="mt-4 flex flex-wrap justify-center gap-3">
            <label for="tempo" class="text-lg">Tempo (BPM):</label>
            <input type="number" id="tempo" value="140" min="60" max="240" class="tempo-input py-2 px-3 rounded-md w-24 text-center" aria-label="Set Tempo (60-240 BPM)">
        </div>
        <!-- Style Buttons -->
         <label class="text-lg">Random Tune Generators:</label>
        <div class="mt-4 flex flex-wrap justify-center gap-3">
            <button id="actionBtn" class="style-button py-2 px-4 rounded-md" role="button" aria-label="Generate Action Sequence">Action</button>
            <button id="mysticalBtn" class="style-button py-2 px-4 rounded-md" role="button" aria-label="Generate Mystical Cut Scene">Mystical</button>
            <button id="shantyBtn" class="style-button py-2 px-4 rounded-md" role="button" aria-label="Generate Fun Shanty">Shanty</button>
        </div>

        <!-- Message Box -->
        <div id="messageBox" class="message-box hidden">
            <p id="messageText" class="text-center"></p>
        </div>
    </div>

    <script>
        // --- Global Variables ---
        const rows = 16;
        const cols = 64;
        const PERCUSSION_ROWS = { 15: 'kk', 14: 'sn', 13: 'hh' };
        const notes = ["C6", "B5", "A5", "G5", "F5", "E5", "D5", "C5", "B4", "A4", "G4", "F4", "E4", "D4", "C4", "B3"];
        let activeNotes = Array(rows).fill(0).map(() => Array(cols).fill().map(() => ({ active: false, duration: "4n" })));
        let rowVolumes = Array(rows).fill(-12); // Default volume: -12 dB
        let currentColumn = 0;
        let isPlaying = false;
        let loop;
        let currentInstrument = 'triangle';
        let currentNoteDuration = "4n";
        const DEFAULT_TEMPO = 140;

        // --- Tone.js Synths ---
        const squareSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "square" },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 }
        }).toDestination();

        const triangleSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "triangle" },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0.05 }
        }).toDestination();

        const sawtoothSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sawtooth" },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 }
        }).toDestination();

        const kickSynth = new Tone.NoiseSynth({
            noise: { type: "brown" },
            envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.2 }
        }).toDestination();

        const snareSynth = new Tone.NoiseSynth({
            noise: { type: "white" },
            envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.15 }
        }).connect(new Tone.Filter(1000, "highpass")).toDestination();

        const hihatSynth = new Tone.NoiseSynth({
            noise: { type: "pink" },
            envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
        }).connect(new Tone.Filter({ frequency: 6000, type: "bandpass", Q: 8})).toDestination();

        // --- DOM Elements ---
        const sequencerGrid = document.getElementById('sequencerGrid');
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const clearBtn = document.getElementById('clearBtn');
        const saveBtn = document.getElementById('saveBtn');
        const loadBtn = document.getElementById('loadBtn');
        const randomizeBtn = document.getElementById('randomizeBtn');
        const exportBtn = document.getElementById('exportBtn');
        const tempoInput = document.getElementById('tempo');
        const squareBtn = document.getElementById('squareBtn');
        const triangleBtn = document.getElementById('triangleBtn');
        const sawtoothBtn = document.getElementById('sawtoothBtn');
        const noiseBtn = document.getElementById('noiseBtn');
        const duration16nBtn = document.getElementById('duration16nBtn');
        const duration8nBtn = document.getElementById('duration8nBtn');
        const duration4nBtn = document.getElementById('duration4nBtn');
        const duration2nBtn = document.getElementById('duration2nBtn');
        const duration1nBtn = document.getElementById('duration1nBtn');
        const actionBtn = document.getElementById('actionBtn');
        const mysticalBtn = document.getElementById('mysticalBtn');
        const shantyBtn = document.getElementById('shantyBtn');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const tempoBar = document.getElementById('tempoBar');

        // --- Functions ---
        function showMessage(message) {
            messageText.textContent = message;
            messageBox.classList.remove('hidden');
            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, 3000);
        }

        function adjustVolume(row, increment) {
            rowVolumes[row] = Math.min(0, Math.max(-30, rowVolumes[row] + increment));
            const volumeDisplay = document.querySelector(`.note-label[data-row="${row}"] .volume-display`);
            if (volumeDisplay) {
                volumeDisplay.textContent = `${rowVolumes[row]}`;
            }
            if (row in PERCUSSION_ROWS) {
                const drumType = PERCUSSION_ROWS[row];
                if (drumType === 'kk') kickSynth.volume.value = rowVolumes[row];
                else if (drumType === 'sn') snareSynth.volume.value = rowVolumes[row];
                else if (drumType === 'hh') hihatSynth.volume.value = rowVolumes[row];
            } else {
                squareSynth.volume.value = rowVolumes[row];
                triangleSynth.volume.value = rowVolumes[row];
                sawtoothSynth.volume.value = rowVolumes[row];
            }
            showMessage(`Row ${row in PERCUSSION_ROWS ? PERCUSSION_ROWS[r].toUpperCase() : notes[row]} volume set to ${rowVolumes[row]} dB`);
        }

        function changeNoteDuration(duration, buttonId) {
            currentNoteDuration = duration;
            document.querySelectorAll('.duration-button').forEach(btn => btn.classList.remove('selected'));
            document.getElementById(buttonId).classList.add('selected');
            sequencerGrid.classList.add('duration-highlight');
            setTimeout(() => sequencerGrid.classList.remove('duration-highlight'), 300);
            if (isPlaying) {
                stopSequencer();
                startSequencer();
            }
        }

        function isColumnOccupied(row, col, duration) {
            const durationColumns = {
                '16n': 1,
                '8n': 2,
                '4n': 4,
                '2n': 8,
                '1n': 16
            }[duration] || 1;
            for (let c = Math.max(0, col - 15); c <= col && c < cols; c++) {
                if (activeNotes[row][c].active) {
                    const existingDuration = activeNotes[row][c].duration;
                    const existingSpan = {
                        '16n': 1,
                        '8n': 2,
                        '4n': 4,
                        '2n': 8,
                        '1n': 16
                    }[existingDuration] || 1;
                    if (c + existingSpan > col && c <= col + durationColumns - 1) {
                        return true;
                    }
                }
            }
            return false;
        }

        function createGrid() {
            sequencerGrid.innerHTML = '';
            const noteLabelsContainer = document.querySelector('.note-labels');
            noteLabelsContainer.innerHTML = '';

            // Calculate maximum columns needed
            let maxCols = 64; // Minimum 64 columns for playback loop
            const durationColumns = {
                '16n': 1,
                '8n': 2,
                '4n': 4,
                '2n': 8,
                '1n': 16
            };
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (activeNotes[r][c].active) {
                        const duration = activeNotes[r][c].duration;
                        const span = durationColumns[duration] || 1;
                        maxCols = Math.max(maxCols, c + span + 1); // Ensure full note length is included
                    }
                }
            }

            // Set grid columns and width
            const columnWidth = window.innerWidth <= 768 ? 14 : 18;
            sequencerGrid.style.gridTemplateColumns = `repeat(${maxCols}, ${columnWidth}px)`;
            sequencerGrid.style.width = `${maxCols * columnWidth}px`;

            // Generate dynamic beat markers
            let beatMarkerStyles = '';
            for (let i = 0; i < maxCols; i += 4) {
                beatMarkerStyles += `calc(${columnWidth}px * ${i}) 0 0 0 rgba(177, 59, 255, 0.3), `;
            }
            beatMarkerStyles = beatMarkerStyles.slice(0, -2);
            const styleSheet = document.createElement('style');
            styleSheet.textContent = `
                .grid::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    bottom: 0;
                    width: 1px;
                    background: rgba(177, 59, 255, 0.3);
                    z-index: 2;
                    left: 0;
                    box-shadow: ${beatMarkerStyles};
                }
            `;
            document.head.appendChild(styleSheet);

            for (let r = 0; r < rows; r++) {
                const labelContainer = document.createElement('div');
                labelContainer.classList.add('note-label');
                labelContainer.setAttribute('aria-hidden', 'true');
                labelContainer.dataset.row = r;

                const labelText = document.createElement('span');
                labelText.textContent = r in PERCUSSION_ROWS ? PERCUSSION_ROWS[r].toUpperCase() : notes[r];
                labelContainer.appendChild(labelText);

                const volumeUp = document.createElement('button');
                volumeUp.textContent = '+';
                volumeUp.classList.add('volume-button');
                volumeUp.setAttribute('aria-label', `Increase volume for ${notes[r]}`);
                volumeUp.addEventListener('click', () => adjustVolume(r, 3));
                volumeUp.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    adjustVolume(r, 3);
                });
                labelContainer.appendChild(volumeUp);

                const volumeDisplay = document.createElement('span');
                volumeDisplay.classList.add('volume-display');
                volumeDisplay.textContent = `${rowVolumes[r]}`;
                volumeDisplay.setAttribute('aria-hidden', 'true');
                labelContainer.appendChild(volumeDisplay);

                const volumeDown = document.createElement('button');
                volumeDown.textContent = '−';
                volumeDown.classList.add('volume-button');
                volumeDown.setAttribute('aria-label', `Decrease volume for ${notes[r]}`);
                volumeDown.addEventListener('click', () => adjustVolume(r, -3));
                volumeDown.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    adjustVolume(r, -3);
                });
                labelContainer.appendChild(volumeDown);

                noteLabelsContainer.appendChild(labelContainer);

                let c = 0;
                while (c < maxCols) {
                    if (c < cols && activeNotes[r][c] && activeNotes[r][c].active) {
                        const duration = activeNotes[r][c].duration;
                        const span = Math.min(durationColumns[duration] || 1, maxCols - c);
                        for (let i = c + 1; i < c + span && i < cols; i++) {
                            activeNotes[r][i] = { active: false, duration: "4n" };
                        }
                        const cell = document.createElement('div');
                        cell.classList.add('grid-cell', 'rounded-sm');
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        cell.style.gridColumn = `${c + 1} / span ${span}`;
                        const durationLabel = {
                            '1n': 'Whole note',
                            '2n': 'Half note',
                            '4n': 'Quarter note',
                            '8n': 'Eighth note',
                            '16n': 'Sixteenth note'
                        }[duration] || 'Note';
                        cell.setAttribute('role', 'button');
                        cell.setAttribute('aria-label', `${durationLabel} ${r in PERCUSSION_ROWS ? PERCUSSION_ROWS[r].toUpperCase() : notes[r]} spanning ${span} steps at step ${c + 1}`);
                        cell.setAttribute('tabindex', '0');
                        cell.addEventListener('click', toggleNote);
                        cell.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            toggleNote(e);
                        });
                        cell.classList.add('active', `duration-${duration}`);
                        cell.title = durationLabel;
                        sequencerGrid.appendChild(cell);
                        c += span;
                    } else {
                        const cell = document.createElement('div');
                        cell.classList.add('grid-cell', 'rounded-sm');
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        cell.style.gridColumn = `${c + 1} / span 1`;
                        cell.setAttribute('role', 'button');
                        cell.setAttribute('aria-label', `Empty ${r in PERCUSSION_ROWS ? PERCUSSION_ROWS[r].toUpperCase() : notes[r]} at step ${c + 1}`);
                        cell.setAttribute('tabindex', '0');
                        cell.addEventListener('click', toggleNote);
                        cell.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            toggleNote(e);
                        });
                        cell.title = 'Empty';
                        sequencerGrid.appendChild(cell);
                        c++;
                    }
                }
            }
        }

        function toggleNote(event) {
            const cell = event.target;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            // Clear any overlapping notes
            const newDuration = activeNotes[row][col].active ? "4n" : currentNoteDuration;
            const durationColumns = {
                '16n': 1,
                '8n': 2,
                '4n': 4,
                '2n': 8,
                '1n': 16
            }[newDuration] || 1;
            // Prevent adding notes that extend beyond playback grid
            if (col + durationColumns > cols) {
                showMessage(`Cannot place ${newDuration} note at column ${col + 1}; it would exceed the 64-column playback grid.`);
                return;
            }
            for (let c = 0; c < cols; c++) {
                if (activeNotes[row][c].active) {
                    const existingDuration = activeNotes[row][c].duration;
                    const existingSpan = {
                        '16n': 1,
                        '8n': 2,
                        '4n': 4,
                        '2n': 8,
                        '1n': 16
                    }[existingDuration] || 1;
                    if (c < col + durationColumns && c + existingSpan > col) {
                        for (let i = c; i < c + existingSpan && i < cols; i++) {
                            activeNotes[row][i] = { active: false, duration: "4n" };
                        }
                    }
                }
            }
            // Toggle the note
            activeNotes[row][col] = {
                active: !activeNotes[row][col].active,
                duration: newDuration
            };
            createGrid(); // Rebuild grid to update spans
        }

        function playColumn(time) {
            const notesToPlay = [];

            for (let r = 0; r < rows; r++) {
                if (activeNotes[r][currentColumn].active) {
                    const duration = activeNotes[r][currentColumn].duration;

                    // Percussion handling
                    if (r in PERCUSSION_ROWS) {
                        const drumType = PERCUSSION_ROWS[r];
                        switch (drumType) {
                            case 'kk':
                                kickSynth.volume.value = rowVolumes[r];
                                kickSynth.triggerAttackRelease(duration, time);
                                break;
                            case 'sn':
                                snareSynth.volume.value = rowVolumes[r];
                                snareSynth.triggerAttackRelease(duration, time);
                                break;
                            case 'hh':
                                hihatSynth.volume.value = rowVolumes[r];
                                hihatSynth.triggerAttackRelease(duration, time);
                                break;
                        }
                    } else {
                        notesToPlay.push({ note: notes[r], duration, volume: rowVolumes[r] });
                    }
                }
            }

            // Play melodic notes according to current instrument
            if (notesToPlay.length > 0) {
                switch (currentInstrument) {
                    case 'square':
                        notesToPlay.forEach(({ note, duration, volume }) => {
                            squareSynth.volume.value = volume;
                            squareSynth.triggerAttackRelease(note, duration, time);
                        });
                        break;
                    case 'triangle':
                        notesToPlay.forEach(({ note, duration, volume }) => {
                            triangleSynth.volume.value = volume;
                            triangleSynth.triggerAttackRelease(note, duration, time);
                        });
                        break;
                    case 'sawtooth':
                        notesToPlay.forEach(({ note, duration, volume }) => {
                            sawtoothSynth.volume.value = volume;
                            sawtoothSynth.triggerAttackRelease(note, duration, time);
                        });
                        break;
                    case 'noise':
                        notesToPlay.forEach(({ duration, volume }) => {
                            const noise = new Tone.NoiseSynth({
                                noise: { type: "white" },
                                envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
                            }).toDestination();
                            noise.volume.value = volume;
                            noise.triggerAttackRelease(duration, time);
                        });
                        break;
                }
            }

            // Advance to the next column regardless of notes played
            currentColumn = (currentColumn + 1) % cols;

            // Update UI to highlight the playing column
            document.querySelectorAll('.grid-cell').forEach(cell => cell.classList.remove('playing'));
            document.querySelectorAll(`.grid-cell[data-col="${currentColumn}"]`).forEach(cell => cell.classList.add('playing'));
        }


        // Play sounds for notes starting at the current column
        const notesToPlay = [];
        for (let r = 0; r < rows; r++) {
            if (activeNotes[r][currentColumn].active) {
                const duration = activeNotes[r][currentColumn].duration;
                if (r in PERCUSSION_ROWS) {
                    const drumType = PERCUSSION_ROWS[r];
                    if (drumType === 'kk') {
                        kickSynth.volume.value = rowVolumes[r];
                        kickSynth.triggerAttackRelease(duration, time);
                    } else if (drumType === 'sn') {
                        snareSynth.volume.value = rowVolumes[r];
                        snareSynth.triggerAttackRelease(duration, time);
                    } else if (drumType === 'hh') {
                        hihatSynth.volume.value = rowVolumes[r];
                        hihatSynth.triggerAttackRelease(duration, time);
                    }
                } else {
                    notesToPlay.push({ note: notes[r], duration });
                }
            }
        }
        if (notesToPlay.length > 0) {
            switch (currentInstrument) {
                case 'square':
                    squareSynth.volume.value = rowVolumes[notes.indexOf(notesToPlay[0].note)];
                    notesToPlay.forEach(({ note, duration }) => {
                        squareSynth.triggerAttackRelease(note, duration, time);
                    });
                    break;
                case 'triangle':
                    triangleSynth.volume.value = rowVolumes[notes.indexOf(notesToPlay[0].note)];
                    notesToPlay.forEach(({ note, duration }) => {
                        triangleSynth.triggerAttackRelease(note, duration, time);
                    });
                    break;
                case 'sawtooth':
                    sawtoothSynth.volume.value = rowVolumes[notes.indexOf(notesToPlay[0].note)];
                    notesToPlay.forEach(({ note, duration }) => {
                        sawtoothSynth.triggerAttackRelease(note, duration, time);
                    });
                    break;
            }
        // Advance to the next column
        currentColumn = (currentColumn + 1) % cols;
        }

        async function startSequencer() {
            if (isPlaying) return;
            await Tone.start();
            Tone.Transport.bpm.value = parseInt(tempoInput.value) || DEFAULT_TEMPO;
            const tempo = parseInt(tempoInput.value) || DEFAULT_TEMPO;
            const sixteenthNoteDuration = 60 / tempo / 4; // Seconds per 16n
            tempoBar.style.transition = `left ${sixteenthNoteDuration}s linear`;
            if (loop) loop.dispose();
            loop = new Tone.Loop(playColumn, "16n"); // Use 16n for precise column advancement
            loop.start(0);
            Tone.Transport.start();
            isPlaying = true;
            currentColumn = 0; // Reset to ensure status bar starts at beginning
            playBtn.textContent = 'Playing...';
            playBtn.disabled = true;
            stopBtn.disabled = false;
            tempoBar.style.display = 'block'; // Show tempo bar
        }

        function stopSequencer() {
            if (!isPlaying) return;
            Tone.Transport.stop();
            if (loop) loop.stop();
            isPlaying = false;
            playBtn.textContent = 'Play';
            playBtn.disabled = false;
            stopBtn.disabled = true;
            document.querySelectorAll('.grid-cell').forEach(cell => cell.classList.remove('playing'));
            tempoBar.style.display = 'none'; // Hide tempo bar
            currentColumn = 0; // Reset column for next playback
        }

        function clearGrid() {
            activeNotes = Array(rows).fill(0).map(() => Array(cols).fill().map(() => ({ active: false, duration: "4n" })));
            createGrid();
            showMessage('Grid cleared!');
        }

        function saveSequence() {
            localStorage.setItem('sequencerNotes', JSON.stringify(activeNotes));
            showMessage('Sequence saved!');
        }

        function loadSequence() {
            const saved = localStorage.getItem('sequencerNotes');
            if (saved) {
                activeNotes = JSON.parse(saved);
                createGrid();
                showMessage('Sequence loaded!');
            } else {
                showMessage('No saved sequence found.');
            }
        }

        function randomizeGrid() {
            sequencerGrid.classList.add('randomized');
            setTimeout(() => sequencerGrid.classList.remove('randomized'), 500);
            activeNotes = Array(rows).fill(0).map(() => Array(cols).fill().map(() => ({ active: false, duration: "4n" })));
            const durationOptions = [
                { duration: "16n", weight: 0.25 },
                { duration: "8n", weight: 0.25 },
                { duration: "4n", weight: 0.20 },
                { duration: "2n", weight: 0.20 },
                { duration: "1n", weight: 0.10 }
            ];
            const totalWeight = durationOptions.reduce((sum, opt) => sum + opt.weight, 0);
            const durationColumns = {
                '16n': 1,
                '8n': 2,
                '4n': 4,
                '2n': 8,
                '1n': 16
            };

            // Melody (rows 0–9, C6–A4)
            for (let c = 0; c < cols; c += 4) { // Align to quarter-note beats
                const melodyRow = Math.floor(Math.random() * 10); // Rows 0–9
                if (Math.random() < 0.6) { // 60% chance to place a melody note
                    let rand = Math.random() * totalWeight;
                    let selectedDuration = "4n";
                    for (const option of durationOptions) {
                        rand -= option.weight;
                        if (rand <= 0) {
                            selectedDuration = option.duration;
                            break;
                        }
                    }
                    const span = durationColumns[selectedDuration];
                    if (c + span <= cols && !isColumnOccupied(melodyRow, c, selectedDuration)) {
                        activeNotes[melodyRow][c] = { active: true, duration: selectedDuration };
                        for (let i = c + 1; i < c + span && i < cols; i++) {
                            activeNotes[melodyRow][i] = { active: false, duration: "4n" };
                        }
                    }
                }
            }

            // Percussion (rows 13–15: hh, sn, kk)
            for (let c = 0; c < cols; c += 4) {
                // Hi-hat (row 13)
                const hiHatDuration = Math.random() < 0.5 ? "8n" : "16n";
                if (!isColumnOccupied(13, c, hiHatDuration)) {
                    activeNotes[13][c] = { active: Math.random() < 0.8, duration: hiHatDuration };
                }
                if (c + 1 < cols && !isColumnOccupied(13, c + 1, "16n")) {
                    activeNotes[13][c + 1] = { active: Math.random() < 0.4, duration: "16n" };
                }
                // Snare (row 14)
                const snareDuration = Math.random() < 0.5 ? "4n" : "8n";
                if (c + 2 < cols && !isColumnOccupied(14, c + 2, snareDuration)) {
                    activeNotes[14][c + 2] = { active: Math.random() < 0.7, duration: snareDuration };
                }
                // Kick (row 15)
                const kickDuration = Math.random() < 0.5 ? "4n" : "8n";
                if (!isColumnOccupied(15, c, kickDuration)) {
                    activeNotes[15][c] = { active: Math.random() < 0.6, duration: kickDuration };
                }
                // Additional percussion for variety
                if (c % 16 === 0 && c + 3 < cols) {
                    if (!isColumnOccupied(14, c + 3, "8n")) {
                        activeNotes[14][c + 3] = { active: Math.random() < 0.5, duration: "8n" };
                    }
                    if (!isColumnOccupied(13, c + 2, "16n")) {
                        activeNotes[13][c + 2] = { active: Math.random() < 0.5, duration: "16n" };
                    }
                }
            }

            createGrid();
            showMessage('Grid randomized with varied note lengths and rhythmic structure!');
        }

        async function exportAudio() {
            showMessage('Exporting... Please wait.');

            // Create an offline context that matches the full sequence duration
            const duration = cols * Tone.Time("16n").toSeconds();
            const buffer = await Tone.Offline(({ transport }) => {
                // Synths for offline rendering
                const offlineSquareSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "square" },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 }
                }).toDestination();

                const offlineTriangleSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 }
                }).toDestination();

                const offlineSawtoothSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "sawtooth" },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 }
                }).toDestination();

                const offlineKickSynth = new Tone.NoiseSynth({
                    noise: { type: "brown" },
                    envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.2 }
                }).toDestination();

                const offlineSnareSynth = new Tone.NoiseSynth({
                    noise: { type: "white" },
                    envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.15 }
                }).connect(new Tone.Filter(1000, "highpass")).toDestination();

                const offlineHihatSynth = new Tone.NoiseSynth({
                    noise: { type: "pink" },
                    envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
                }).connect(new Tone.Filter({ frequency: 6000, type: "bandpass", Q: 5 })).toDestination();

                // Schedule playback for each column
                let col = 0;
                const loop = new Tone.Loop((time) => {
                    const notesToPlay = [];

                    for (let r = 0; r < rows; r++) {
                        if (activeNotes[r][col].active) {
                            const duration = activeNotes[r][col].duration;
                            if (r in PERCUSSION_ROWS) {
                                const drumType = PERCUSSION_ROWS[r];
                                switch (drumType) {
                                    case 'kk':
                                        offlineKickSynth.volume.value = rowVolumes[r];
                                        offlineKickSynth.triggerAttackRelease(duration, time);
                                        break;
                                    case 'sn':
                                        offlineSnareSynth.volume.value = rowVolumes[r];
                                        offlineSnareSynth.triggerAttackRelease(duration, time);
                                        break;
                                    case 'hh':
                                        offlineHihatSynth.volume.value = rowVolumes[r];
                                        offlineHihatSynth.triggerAttackRelease(duration, time);
                                        break;
                                }
                            } else {
                                notesToPlay.push({ note: notes[r], duration, volume: rowVolumes[r] });
                            }
                        }
                    }

                    // Play melodic notes according to instrument
                    if (notesToPlay.length > 0) {
                        switch (currentInstrument) {
                            case 'square':
                                notesToPlay.forEach(({ note, duration, volume }) => {
                                    offlineSquareSynth.volume.value = volume;
                                    offlineSquareSynth.triggerAttackRelease(note, duration, time);
                                });
                                break;
                            case 'triangle':
                                notesToPlay.forEach(({ note, duration, volume }) => {
                                    offlineTriangleSynth.volume.value = volume;
                                    offlineTriangleSynth.triggerAttackRelease(note, duration, time);
                                });
                                break;
                            case 'sawtooth':
                                notesToPlay.forEach(({ note, duration, volume }) => {
                                    offlineSawtoothSynth.volume.value = volume;
                                    offlineSawtoothSynth.triggerAttackRelease(note, duration, time);
                                });
                                break;
                        }
                    }

                    col = (col + 1) % cols;
                }, "16n");

                loop.start(0);
                transport.start();
            }, duration);

            // Convert to WAV
            const wav = Tone.Buffer.toWav(buffer);
            const blob = new Blob([wav], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);

            // Trigger download
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sequence.wav';
            a.click();

            URL.revokeObjectURL(url);
            showMessage('Sequence exported as WAV!');
        }


        function changeInstrument(instrumentName) {
            currentInstrument = instrumentName;
            document.querySelectorAll('.instrument-button').forEach(btn => btn.classList.remove('selected'));
            document.getElementById(`${instrumentName}Btn`).classList.add('selected');
        }

        function generateActionSequence() {
            activeNotes = Array(rows).fill(0).map(() => Array(cols).fill().map(() => ({ active: false, duration: "8n" })));
            // Two melody lines with varied durations
            for (let c = 0; c < cols; c += 8) {
                // Primary melody (C6 to G5, rows 0-4)
                const melodyRow1 = Math.floor(Math.random() * 5);
                const motif = [0, 2, 4, 6];
                motif.forEach(offset => {
                    if (c + offset < cols && Math.random() < 0.8 && !isColumnOccupied(melodyRow1, c + offset, "4n")) {
                        const duration = Math.random() < 0.3 ? "2n" : Math.random() < 0.5 ? "4n" : "8n";
                        activeNotes[melodyRow1][c + offset] = { active: true, duration };
                    }
                });
                // Secondary melody (C5 to A4, rows 7-9)
                const melodyRow2 = Math.floor(Math.random() * 3) + 7;
                const motif2 = [1, 3, 5, 7];
                motif2.forEach(offset => {
                    if (c + offset < cols && Math.random() < 0.6 && !isColumnOccupied(melodyRow2, c + offset, "8n")) {
                        const duration = Math.random() < 0.4 ? "4n" : "8n";
                        activeNotes[melodyRow2][c + offset] = { active: true, duration };
                    }
                });
                // Sustained chords (G4 to C4, rows 11-13)
                if (Math.random() < 0.7) {
                    const rootRow = Math.floor(Math.random() * 3) + 11;
                    const duration = Math.random() < 0.5 ? "1n" : "2n";
                    if (!isColumnOccupied(rootRow, c, duration)) {
                        activeNotes[rootRow][c] = { active: true, duration };
                        if (rootRow + 2 < rows - 3 && !isColumnOccupied(rootRow + 2, c, duration)) {
                            activeNotes[rootRow + 2][c] = { active: true, duration };
                        }
                        if (rootRow + 4 < rows - 3 && !isColumnOccupied(rootRow + 4, c, duration)) {
                            activeNotes[rootRow + 4][c] = { active: true, duration };
                        }
                    }
                }
            }
            // Varied percussion
            for (let c = 0; c < cols; c += 4) {
                const kickDuration = Math.random() < 0.5 ? "4n" : "8n";
                const snareDuration = Math.random() < 0.5 ? "4n" : "8n";
                if (!isColumnOccupied(15, c, kickDuration)) {
                    activeNotes[15][c] = { active: Math.random() < 0.9, duration: kickDuration };
                }
                if (c + 2 < cols && !isColumnOccupied(14, c + 2, snareDuration)) {
                    activeNotes[14][c + 2] = { active: Math.random() < 0.8, duration: snareDuration };
                }
                if (!isColumnOccupied(13, c, "8n")) {
                    activeNotes[13][c] = { active: Math.random() < 0.7, duration: "8n" };
                }
                if (c + 1 < cols && !isColumnOccupied(13, c + 1, "16n")) {
                    activeNotes[13][c + 1] = { active: Math.random() < 0.5, duration: "16n" };
                }
                if (c % 16 === 0 && c + 3 < cols) {
                    if (!isColumnOccupied(14, c + 3, "8n")) {
                        activeNotes[14][c + 3] = { active: Math.random() < 0.6, duration: "8n" };
                    }
                    if (!isColumnOccupied(13, c + 2, "16n")) {
                        activeNotes[13][c + 2] = { active: Math.random() < 0.4, duration: "16n" };
                    }
                }
            }
            changeNoteDuration('8n', 'duration8nBtn');
            Tone.Transport.bpm.value = 140;
            tempoInput.value = 140;
            createGrid();
            showMessage('Action sequence generated!');
        }

        function generateMysticalCutScene() {
            activeNotes = Array(rows).fill(0).map(() => Array(cols).fill().map(() => ({ active: false, duration: "4n" })));
            // Arpeggios and sustained pads
            for (let c = 0; c < cols; c += 16) {
                const baseRow = Math.floor(Math.random() * 4); // C6 to F5
                const arpeggio = [0, 2, 4, 6, 8, 10, 12, 14]; // 8-step arpeggio
                arpeggio.forEach(offset => {
                    if (c + offset < cols && Math.random() < 0.75) {
                        const rowOffset = Math.floor(Math.random() * 3);
                        if (baseRow + rowOffset < rows - 3) {
                            const duration = Math.random() < 0.2 ? "2n" : Math.random() < 0.4 ? "4n" : Math.random() < 0.6 ? "8n" : "16n";
                            if (!isColumnOccupied(baseRow + rowOffset, c + offset, duration)) {
                                activeNotes[baseRow + rowOffset][c + offset] = { active: true, duration };
                            }
                        }
                    }
                });
                // Sustained harmony pads
                if (Math.random() < 0.8) {
                    const harmonyRow = Math.floor(Math.random() * 3) + 8; // B4 to E4
                    const duration = Math.random() < 0.6 ? "1n" : "2n";
                    if (!isColumnOccupied(harmonyRow, c, duration)) {
                        activeNotes[harmonyRow][c] = { active: true, duration };
                        if (harmonyRow + 3 < rows - 3 && !isColumnOccupied(harmonyRow + 3, c, duration)) {
                            activeNotes[harmonyRow + 3][c] = { active: true, duration };
                        }
                        if (harmonyRow + 5 < rows - 3 && Math.random() < 0.5 && !isColumnOccupied(harmonyRow + 5, c, duration)) {
                            activeNotes[harmonyRow + 5][c] = { active: true, duration };
                        }
                    }
                }
            }
            // Enhanced percussion
            for (let c = 0; c < cols; c += 8) {
                const hiHatDuration = Math.random() < 0.5 ? "8n" : "4n";
                const kickDuration = "4n";
                if (!isColumnOccupied(13, c, hiHatDuration)) {
                    activeNotes[13][c] = { active: Math.random() < 0.7, duration: hiHatDuration };
                }
                if (!isColumnOccupied(15, c, kickDuration)) {
                    activeNotes[15][c] = { active: Math.random() < 0.5, duration: kickDuration };
                }
                if (c + 4 < cols && !isColumnOccupied(13, c + 4, hiHatDuration)) {
                    activeNotes[13][c + 4] = { active: Math.random() < 0.6, duration: hiHatDuration };
                }
                if (c % 16 === 0 && c + 6 < cols) {
                    if (!isColumnOccupied(15, c + 6, kickDuration)) {
                        activeNotes[15][c + 6] = { active: Math.random() < 0.4, duration: kickDuration };
                    }
                    if (!isColumnOccupied(14, c + 6, "8n")) {
                        activeNotes[14][c + 6] = { active: Math.random() < 0.3, duration: "8n" };
                    }
                }
            }
            changeNoteDuration('4n', 'duration4nBtn'); // Default for manual toggles
            Tone.Transport.bpm.value = 100;
            tempoInput.value = 100;
            createGrid();
            showMessage('Mystical cut scene generated!');
        }

        function generateFunShanty() {
            activeNotes = Array(rows).fill(0).map(() => Array(cols).fill().map(() => ({ active: false, duration: "8n" })));
            // Call-and-response melody with varied durations
            for (let c = 0; c < cols; c += 8) {
                const melodyRow = Math.floor(Math.random() * 5) + 2; // A5 to E5
                const callMotif = [0, 2, 4];
                callMotif.forEach(offset => {
                    if (c + offset < cols && Math.random() < 0.8 && !isColumnOccupied(melodyRow, c + offset, "8n")) {
                        activeNotes[melodyRow][c + offset] = { active: true, duration: "8n" };
                    }
                });
                // Response with longer notes
                const responseRow = melodyRow + Math.floor(Math.random() * 2) + 2; // Jump 2-3 rows
                const responseMotif = [5, 6, 7];
                responseMotif.forEach(offset => {
                    if (c + offset < cols && Math.random() < 0.7 && responseRow < rows - 3) {
                        const duration = Math.random() < 0.3 ? "2n" : Math.random() < 0.5 ? "4n" : "8n";
                        if (!isColumnOccupied(responseRow, c + offset, duration)) {
                            activeNotes[responseRow][c + offset] = { active: true, duration };
                        }
                    }
                });
                // Sustained harmony
                if (Math.random() < 0.7) {
                    const harmonyRow = Math.floor(Math.random() * 3) + 10; // G4 to E4
                    const duration = Math.random() < 0.6 ? "1n" : "2n";
                    if (!isColumnOccupied(harmonyRow, c, duration)) {
                        activeNotes[harmonyRow][c] = { active: true, duration };
                        if (harmonyRow + 2 < rows - 3 && !isColumnOccupied(harmonyRow + 2, c, duration)) {
                            activeNotes[harmonyRow + 2][c] = { active: true, duration };
                        }
                        if (harmonyRow + 4 < rows - 3 && Math.random() < 0.5 && !isColumnOccupied(harmonyRow + 4, c, duration)) {
                            activeNotes[harmonyRow + 4][c] = { active: true, duration };
                        }
                    }
                }
            }
            // Lively percussion with varied durations
            for (let c = 0; c < cols; c += 4) {
                const kickDuration = Math.random() < 0.5 ? "4n" : "8n";
                const snareDuration = Math.random() < 0.5 ? "4n" : "8n";
                if (!isColumnOccupied(15, c, kickDuration)) {
                    activeNotes[15][c] = { active: Math.random() < 0.8, duration: kickDuration };
                }
                if (c + 2 < cols && !isColumnOccupied(14, c + 2, snareDuration)) {
                    activeNotes[14][c + 2] = { active: Math.random() < 0.7, duration: snareDuration };
                }
                if (!isColumnOccupied(13, c, "8n")) {
                    activeNotes[13][c] = { active: Math.random() < 0.9, duration: "8n" };
                }
                if (c + 1 < cols && !isColumnOccupied(13, c + 1, "16n")) {
                    activeNotes[13][c + 1] = { active: Math.random() < 0.6, duration: "16n" };
                }
                if (c % 16 === 0 && c + 3 < cols) {
                    if (!isColumnOccupied(14, c + 3, "8n")) {
                        activeNotes[14][c + 3] = { active: Math.random() < 0.6, duration: "8n" };
                    }
                    if (!isColumnOccupied(13, c + 2, "16n")) {
                        activeNotes[13][c + 2] = { active: Math.random() < 0.7, duration: "16n" };
                    }
                }
            }
            changeNoteDuration('8n', 'duration8nBtn');
            Tone.Transport.bpm.value = 120;
            tempoInput.value = 120;
            createGrid();
            showMessage('Fun shanty generated!');
        }

        // --- Event Listeners ---
        window.onload = function() {
            createGrid();
            // Helper to add both click and touchstart listeners
            function addClickAndTouch(element, handler) {
                element.addEventListener('click', handler);
                element.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    handler(e);
                });
            }

            // Control buttons
            addClickAndTouch(playBtn, startSequencer);
            addClickAndTouch(stopBtn, stopSequencer);
            addClickAndTouch(clearBtn, clearGrid);
            addClickAndTouch(saveBtn, saveSequence);
            addClickAndTouch(loadBtn, loadSequence);
            addClickAndTouch(randomizeBtn, randomizeGrid);
            addClickAndTouch(exportBtn, exportAudio);
            addClickAndTouch(actionBtn, generateActionSequence);
            addClickAndTouch(mysticalBtn, generateMysticalCutScene);
            addClickAndTouch(shantyBtn, generateFunShanty);

            // Instrument buttons
            addClickAndTouch(squareBtn, () => changeInstrument('square'));
            addClickAndTouch(triangleBtn, () => changeInstrument('triangle'));
            addClickAndTouch(sawtoothBtn, () => changeInstrument('sawtooth'));
            addClickAndTouch(noiseBtn, () => changeInstrument('noise'));

            // Duration buttons
            addClickAndTouch(duration16nBtn, () => changeNoteDuration('16n', 'duration16nBtn'));
            addClickAndTouch(duration8nBtn, () => changeNoteDuration('8n', 'duration8nBtn'));
            addClickAndTouch(duration4nBtn, () => changeNoteDuration('4n', 'duration4nBtn'));
            addClickAndTouch(duration2nBtn, () => changeNoteDuration('2n', 'duration2nBtn'));
            addClickAndTouch(duration1nBtn, () => changeNoteDuration('1n', 'duration1nBtn'));

            // Tempo input
            tempoInput.addEventListener('input', (e) => {
                let value = parseInt(e.target.value);
                if (isNaN(value) || value < 60 || value > 240) {
                    showMessage('Please enter a tempo between 60 and 240 BPM.');
                    e.target.value = DEFAULT_TEMPO;
                    value = DEFAULT_TEMPO;
                }
                Tone.Transport.bpm.value = value;
            });

            // Grid keyboard navigation
            sequencerGrid.addEventListener('keydown', (e) => {
                if (e.target.classList.contains('grid-cell')) {
                    const row = parseInt(e.target.dataset.row);
                    const col = parseInt(e.target.dataset.col);
                    if (e.key === 'ArrowRight' && col < cols - 1) {
                        document.querySelector(`.grid-cell[data-row="${row}"][data-col="${col + 1}"]`).focus();
                        e.preventDefault();
                    } else if (e.key === 'ArrowLeft' && col > 0) {
                        document.querySelector(`.grid-cell[data-row="${row}"][data-col="${col - 1}"]`).focus();
                        e.preventDefault();
                    } else if (e.key === 'ArrowUp' && row > 0) {
                        document.querySelector(`.grid-cell[data-row="${row - 1}"][data-col="${col}"]`).focus();
                        e.preventDefault();
                    } else if (e.key === 'ArrowDown' && row < rows - 1) {
                        document.querySelector(`.grid-cell[data-row="${row + 1}"][data-col="${col}"]`).focus();
                        e.preventDefault();
                    } else if (e.key === ' ' || e.key === 'Enter') {
                        toggleNote(e);
                        e.preventDefault();
                    }
                }
            });

            // Scroll shadow handling
            const gridWrapper = document.querySelector('.grid-wrapper');
            function updateScrollShadows() {
                const scrollLeft = gridWrapper.scrollLeft;
                const scrollWidth = gridWrapper.scrollWidth;
                const clientWidth = gridWrapper.clientWidth;
                gridWrapper.classList.toggle('scroll-left', scrollLeft > 0);
                gridWrapper.classList.toggle('scroll-right', scrollLeft < scrollWidth - clientWidth - 1);
            }
            gridWrapper.addEventListener('scroll', updateScrollShadows);
            updateScrollShadows(); // Initial check

            // Audio context initialization
            function initializeAudioContext(e) {
                if (Tone.context.state !== 'running') {
                    Tone.start().then(() => {
                        showMessage('Audio context started! Ready to play.');
                    });
                }
                window.removeEventListener('click', initializeAudioContext);
                window.removeEventListener('touchstart', initializeAudioContext);
            }
            window.addEventListener('click', initializeAudioContext, { once: true });
            window.addEventListener('touchstart', initializeAudioContext, { once: true });

            stopBtn.disabled = true;
            showMessage('Create your own 8-bit tune or try the Auto Generated Tunes!');
        };
    </script>
</body>
</html>